/**
 * LODDataSet.java
 * created: 19.01.2008 08:14:40
 * (c) 2008 by <a href="http://Wolschon.biz">Wolschon Softwaredesign und Beratung</a>
 * This file is part of libosm by Marcus Wolschon <a href="mailto:Marcus@Wolscon.biz">Marcus@Wolscon.biz</a>.
 * You can purchase support for a sensible hourly rate or
 * a commercial license of this file (unless modified by others) by contacting him directly.
 *
 *  libosm is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  libosm is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with libosm.  If not, see <http://www.gnu.org/licenses/>.
 *
 ***********************************
 * Editing this file:
 *  -For consistent code-quality this file should be checked with the
 *   checkstyle-ruleset enclosed in this project.
 *  -After the design of this file has settled it should get it's own
 *   JUnit-Test that shall be executed regularly. It is best to write
 *   the test-case BEFORE writing this class and to run it on every build
 *   as a regression-test.
 */
package org.openstreetmap.osm.data;



//automatically created logger for debug and error -output
import java.io.File;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.logging.Logger;

import org.openstreetmap.osm.ConfigurationSection;
import org.openstreetmap.osm.ConfigurationSetting;
import org.openstreetmap.osm.Settings;
import org.openstreetmap.osm.Tags;
import org.openstreetmap.osm.data.coordinates.Bounds;
import org.openstreetmap.osm.data.coordinates.LatLon;
import org.openstreetmap.osm.data.h2.H2DataSet;
import org.openstreetmap.osm.data.osmbin.v1_0.ExtendedNode;
import org.openstreetmap.osm.data.osmbin.v1_0.ExtendedWay;

import org.openstreetmap.osmosis.core.domain.v0_6.EntityType;
import org.openstreetmap.osmosis.core.domain.v0_6.Node;
import org.openstreetmap.osmosis.core.domain.v0_6.Relation;
import org.openstreetmap.osmosis.core.domain.v0_6.RelationBuilder;
import org.openstreetmap.osmosis.core.domain.v0_6.RelationMember;
import org.openstreetmap.osmosis.core.domain.v0_6.Tag;
import org.openstreetmap.osmosis.core.domain.v0_6.Way;
import org.openstreetmap.osmosis.core.domain.v0_6.WayBuilder;
import org.openstreetmap.osmosis.core.domain.v0_6.WayNode;


/**
 * (c) 2008 by <a href="http://Wolschon.biz>Wolschon Softwaredesign und Beratung</a>.<br/>
 * Project: libosm<br/>
 * LODDataSet.java<br/>
 * created: 19.01.2008 08:14:40 <br/>
 *<br/><br/>
 * A Level-Of-Detail DataSet contains one base-Dataset, that
 * contains all data and dynamically fills additional DataSets
 * that only contains a simplified and filtered map.
 * This aids in drawing maps for low zoom levels and long-
 * distance routing.
 * @author <a href="mailto:Marcus@Wolschon.biz">Marcus Wolschon</a>
 *
 */
public class LODDataSet implements IHintableDataSet, IDataSet {

    /**
     * Relation of type=compound and type=street get one (or some) new member(s) of this
     * role that is(are) the simplified concatenation of all contained ways.
     */
    protected static final String SIMPLIFIEDWAYRELATIONROLE = "LODDataSet.simplifiedWay";

    /**
     * We add this tag with the value "true" to all relations we created
     * automatically that are not in the original map.
     * Do not upload such elements to OpenStreetMap. They are used only
     * internally.<br/>
     * The base-dataset never contains autogenerated elements.
     */
    protected static final String AUTOGENERATEDTAG = "LODDataSet.autoGenerated";

    /**
     * Automatically created logger for debug and error-output.
     */
    private static final Logger  LOG = Logger.getLogger(
                                               LODDataSet.class.getName());

    /**
     * The base-dataset contains the unfiltered data.
     */
    private IDataSet myBaseDataSet;

    /**
     * The first, reduced dataset containing only filtered data.
     */
    private IDataSet myLOD1DataSet;

    /**
     * How many decimal places of a tile-number to remove for LOD2.
     */
    //private static final int LOD2_COMBINE_TILE_LEVEL = 3;

    /**
     * The second, reduced dataset containing only filtered data.
     */
    private IDataSet myLOD2DataSet;

    /**
     * How many decimal places of a tile-number to remove for LOD3.
     */
    //private static final int LOD3_COMBINE_TILE_LEVEL = 4;

    /**
     * The third, reduced dataset containing only filtered data.
     */
    private IDataSet myLOD3DataSet;

    /**
     * Just an overridden ToString to return this classe's name
     * and hashCode.
     * @return className and hashCode
     */
    public String toString() {
        return "LODDataSet@" + hashCode();
    }

    /**
     * ${@inheritDoc}.
     */
    public void addNode(final Node aW) {
        if (aW == null) {
            throw new IllegalArgumentException("null node given");
        }
        getBaseDataSet().addNode(aW);
        // nodes are added to myLOD1DataSet/myLOD2DataSet as needed.

        if (myLOD1Selector.isAllowed(getLOD1DataSet(), aW)) {
            getLOD1DataSet().addNode(extendedNodeToNode(aW));
        }
        if (myLOD2Selector.isAllowed(getLOD3DataSet(), aW)) {
            getLOD2DataSet().addNode(extendedNodeToNode(aW));
        }
        if (myLOD3Selector.isAllowed(getLOD3DataSet(), aW)) {
            getLOD3DataSet().addNode(extendedNodeToNode(aW));
        }
    }

    /**
     * The bounding-box of a complete way must
     * be at least this large for the way to
     * be included in LOD1 (view complete city).
     * @see #myLOD1DataSet
     */
    private final double minSizeLOD1 = 0.006; // 0.005 lat =327m, 0.005lon=560m in europe
    /**
     * The bounding-box of a complete way must
     * be at least this large for the way to
     * be included in LOD2 (view complete state).
     * @see #myLOD2DataSet
     */
    private final double minSizeLOD2 = 0.01; // 0.01 lat =654m, 0.01lon=1.115Km in europe
    /**
     * The bounding-box of a complete way must
     * be at least this large for the way to
     * be included in LOD3 (view complete country/continent).
     * @see #myLOD3DataSet
     */
    private final double minSizeLOD3 = 0.05; // 0.05 lat =3.271Km, 0.05lon=5.566Km in europe

    /**
     * Parameter for the simplification of
     * curves applied to ways or inclusion
     * in LOD1 (view complete city) in meters.
     * This the the maximum course-error for 3
     * consecutive points after removing the moddle
     * node.
     * @see #myLOD1DataSet
     */
    private final double simplificationThresholdLOD1 = 80;

    /**
     * Parameter for the simplification of
     * curves applied to ways or inclusion
     * in LOD2 (view complete state) in meters.
     * This the the maximum course-error for 3
     * consecutive points after removing the moddle
     * node.
     * @see #myLOD2DataSet
     */
    private final double simplificationThresholdLOD2 = 800;
    /**
     * Parameter for the simplification of
     * curves applied to ways or inclusion
     * in LOD3 (view complete country/continent) in meters.
     * This the the maximum course-error for 3
     * consecutive points after removing the moddle
     * node.
     * @see #myLOD3DataSet
     */
    private final double simplificationThresholdLOD3 = 3000;
    /**
     * 2 consecutive nodes in a way may not be further
     * apart in a ways after simplification for inclusion
     * in LOD1 (view complete city).
     * @see #myLOD1DataSet
     */
    private final double nodeDistanceThresholdLOD1 = 0.004; // 0.001 lat =65m, 0.001lon=129m in europe

    /**
     * 2 consecutive nodes in a way may not be further
     * apart in a ways after simplification for inclusion
     * in LOD2 (view complete state).
     * @see #myLOD2DataSet
     */
    private final double nodeDistanceThresholdLOD2 = 0.02; // 0.005 lat =327m, 0.005lon=560m in europe

    /**
     * 2 consecutive nodes in a way may not be further
     * apart in a ways after simplification for inclusion
     * in LOD3 (view complete country/continent).
     * @see #myLOD3DataSet
     */
    private final double nodeDistanceThresholdLOD3 = 0.04; // 0.01 lat =654m, 0.01lon=1.115Km in europe

    /**
     * Selector used for filtering what elements are allowed in
     * LOD1 (view complete city).
     */
    private Selector myLOD1Selector = new LOD1Selector();

    /**
     * Selector used for filtering what elements are allowed in
     * LOD2 (view complete state).
     */
    private Selector myLOD2Selector = new LOD2Selector();

    /**
     * Selector used for filtering what elements are allowed in
     * LOD3 (view complete country/continent).
     */
    private Selector myLOD3Selector = new LOD3Selector();

    /**
     * ${@inheritDoc}.
     */
    public void addRelation(final Relation aR) {
        getBaseDataSet().addRelation(aR);
        if (isCompoundWay(aR)) {
            // remove automatically generated type=compound
            // -relations if aR is a user-generated one
            if (!isAutoGenerated(aR.getTags())) {
                List<RelationMember> toAdd = aR.getMembers();
                for (RelationMember relationMember : toAdd) {
                    if (relationMember.getMemberType() != EntityType.Way) {
                        continue;
                    }
                    if (relationMember.getMemberRole() != null && relationMember.getMemberRole().equalsIgnoreCase(SIMPLIFIEDWAYRELATIONROLE)) {
                        continue;
                    }
                    Way memberWay = getLOD1DataSet().getWaysByID(relationMember.getMemberId());
                    if (memberWay != null) {
                        Relation otherRelation = getCompoundRelation(memberWay, getLOD1DataSet());
                        if (otherRelation != null && isAutoGenerated(otherRelation.getTags())) {
                            getLOD1DataSet().removeRelation(otherRelation);
                        }
                    }
                    memberWay = getLOD2DataSet().getWaysByID(relationMember.getMemberId());
                    if (memberWay != null) {
                        Relation otherRelation = getCompoundRelation(memberWay, getLOD2DataSet());
                        if (otherRelation != null && isAutoGenerated(otherRelation.getTags())) {
                            getLOD2DataSet().removeRelation(otherRelation);
                        }
                    }
                    memberWay = getLOD3DataSet().getWaysByID(relationMember.getMemberId());
                    if (memberWay != null) {
                        Relation otherRelation = getCompoundRelation(memberWay, getLOD3DataSet());
                        if (otherRelation != null && isAutoGenerated(otherRelation.getTags())) {
                            getLOD3DataSet().removeRelation(otherRelation);
                        }
                    }
                }
            }
            RelationBuilder compoundWayRelationWithSimplifiedRoles = null;
            WayBuilder[] compoundWaysBaseLOD = null;
            // combine all parts of the relation into a single way
            compoundWayRelationWithSimplifiedRoles = new RelationBuilder(aR);
            compoundWaysBaseLOD = combineCompoundWay(compoundWayRelationWithSimplifiedRoles, null);


            combineSpitWays(getLOD1DataSet(), compoundWayRelationWithSimplifiedRoles, compoundWaysBaseLOD,
                    null, minSizeLOD1, aR, simplificationThresholdLOD1, nodeDistanceThresholdLOD1, myLOD1Selector);
            getLOD1DataSet().addRelation(aR);
            combineSpitWays(getLOD2DataSet(), compoundWayRelationWithSimplifiedRoles, compoundWaysBaseLOD,
                    null, minSizeLOD2, aR, simplificationThresholdLOD2, nodeDistanceThresholdLOD2, myLOD2Selector);
            getLOD2DataSet().addRelation(aR);
            combineSpitWays(getLOD3DataSet(), compoundWayRelationWithSimplifiedRoles, compoundWaysBaseLOD,
                    null, minSizeLOD3, aR, simplificationThresholdLOD3, nodeDistanceThresholdLOD3, myLOD3Selector);
            getLOD3DataSet().addRelation(aR);
        } else {
            if (myLOD1Selector.isAllowed(getLOD1DataSet(), aR)) {
                getLOD1DataSet().addRelation(aR);
            }
            if (myLOD2Selector.isAllowed(getLOD2DataSet(), aR)) {
                getLOD2DataSet().addRelation(aR);
            }
            if (myLOD3Selector.isAllowed(getLOD3DataSet(), aR)) {
                getLOD3DataSet().addRelation(aR);
            }
        }
    }

    /**
     * ${@inheritDoc}.
     */
    public void addWay(final Way aW) {

        // add everything to the base-set
        getBaseDataSet().addWay(aW);

        String highway = WayHelper.getTag(aW, Tags.TAG_HIGHWAY);
        String boundary = WayHelper.getTag(aW, Tags.TAG_BOUNDARY);
        String waterway = WayHelper.getTag(aW, Tags.TAG_WATERWAY);
        String landuse = WayHelper.getTag(aW, Tags.TAG_LANDUSE);
        String natural = WayHelper.getTag(aW, Tags.TAG_NATURAL);

        boolean isLOD1 = false;
        boolean isLOD2 = false;
        Way simpleWay = aW;
        Relation compoundWayLOD1 = null;
        RelationBuilder compoundWayRelationWithSimplifiedRoles = null;
        WayBuilder[] compoundWaysBaseLOD = null;

        if (highway != null || boundary != null || (waterway != null && !waterway.equalsIgnoreCase("riverbank"))) {
            if (myLOD1Selector.isAllowed(getLOD1DataSet(), aW)) {

//warning! This simplification may destroy intersections because
// not all ways are known yet.
                List<WayNode> fewNodes = getWayHelper().simplifyWay(aW, simplificationThresholdLOD1, nodeDistanceThresholdLOD1, false, false);
                if (aW.getWayNodes().size() > fewNodes.size()) {
                    simpleWay = new Way(aW.getId(), aW.getVersion(), aW.getTimestamp(), aW.getUser(), aW.getChangesetId());
                    simpleWay.getTags().addAll(aW.getTags());
                    simpleWay.getWayNodes().addAll(fewNodes);
                }

                // add the nodes needed for this way
                //nodes = getWayHelper().getNodes(simpleWay);

                // get or create the relation of type=compound for the way.
                // combining all parts of a long street split into multiple
                // ways
                compoundWayLOD1 = getOrCreateCompoundWayLOD123(simpleWay);

                // then combine all parts of the relation into a single way
                if (compoundWayLOD1 != null) {
                    compoundWayRelationWithSimplifiedRoles = new RelationBuilder(compoundWayLOD1);
                    compoundWaysBaseLOD = combineCompoundWay(compoundWayRelationWithSimplifiedRoles, simpleWay);

                    // simplify that one and add it with a special role to the relation
                    isLOD1 = combineSpitWays(getLOD1DataSet(), compoundWayRelationWithSimplifiedRoles, compoundWaysBaseLOD, simpleWay, minSizeLOD1,
                            compoundWayLOD1, simplificationThresholdLOD1, nodeDistanceThresholdLOD1,
                            myLOD1Selector);
                }

                //isLOD1 = combineSplitWays(getLOD1DataSet(), simpleWay, nodes, minSizeLOD1, simplificationThresholdLOD1, nodeDistanceThresholdLOD1, myLOD1Selector);
            }
        } else if (landuse != null || natural != null || (waterway != null && waterway.equalsIgnoreCase("riverbank"))) {
            if (myLOD1Selector.isAllowed(getLOD1DataSet(), aW)) {
              //simplify area
                List<WayNode> simpleArea = getBaseDataSet().getWayHelper().simplifyWay(aW, simplificationThresholdLOD1, nodeDistanceThresholdLOD1, false, false);
                WayBuilder simpleAreaWay = new WayBuilder(aW.getId(), aW.getVersion(), aW.getTimestamp(), aW.getUser(), 0);
                simpleAreaWay.getTags().addAll(aW.getTags());
                for (WayNode wayNode : simpleArea) {
                    simpleAreaWay.addWayNode(wayNode);
                    Node node = getBaseDataSet().getNodeByID(wayNode.getNodeId());
                    if (node != null) {
                        getLOD1DataSet().addNode(extendedNodeToNode(node));
                    }
                }
                getLOD1DataSet().addWay(simpleAreaWay.buildEntity());
            }
        }

        if (!isLOD1) {
           return;
        }


        // LOD 2
        if (highway != null || boundary != null) {
            if (myLOD2Selector.isAllowed(getLOD2DataSet(), aW)) {

//warning! This simplification may destroy intersections because
// not all ways are known yet.
//                List<WayNode> fewNodes = getWayHelper().simplifyWay(simpleWay, simplificationThresholdLOD2, nodeDistanceThresholdLOD2, false);
//                if (simpleWay.getWayNodes().size() < fewNodes.size()) {
//                    simpleWay = new Way(aW.getId(), aW.getVersion(), aW.getTimestamp(), aW.getUser(), aW.getTags(), fewNodes);
//                    // set the nodes needed for the simplified way
//                    nodes = getWayHelper().getNodes(simpleWay);
//               }
                // combine all parts of the relation into a single way
                // simplify that one and add it with a special role to the relation
                isLOD2 = combineSpitWays(getLOD2DataSet(), compoundWayRelationWithSimplifiedRoles, compoundWaysBaseLOD, simpleWay, minSizeLOD2,
                        compoundWayLOD1, simplificationThresholdLOD2, nodeDistanceThresholdLOD2, myLOD2Selector);

//                isLOD2 = combineSplitWays(getLOD2DataSet(), simpleWay, nodes, minSizeLOD2, simplificationThresholdLOD2, nodeDistanceThresholdLOD2, myLOD2Selector);
            }
        } else if (landuse != null || natural != null) {
            if (myLOD2Selector.isAllowed(getLOD2DataSet(), aW)) {
              //simplify area
                List<WayNode> simpleArea = getBaseDataSet().getWayHelper().simplifyWay(aW, simplificationThresholdLOD2, nodeDistanceThresholdLOD2, false, false);
                WayBuilder simpleAreaWay = new WayBuilder(aW.getId(), aW.getVersion(), aW.getTimestamp(), aW.getUser(), 0);
                simpleAreaWay.getTags().addAll(aW.getTags());
                for (WayNode wayNode : simpleArea) {
                    simpleAreaWay.addWayNode(wayNode);
                    Node node = getBaseDataSet().getNodeByID(wayNode.getNodeId());
                    if (node != null) {
                        getLOD2DataSet().addNode(extendedNodeToNode(node));
                    }
                }
                getLOD2DataSet().addWay(simpleAreaWay.buildEntity());
            }
        }
        if (!isLOD2) {
           return;
        }


//      LOD 3
        if (highway != null || boundary != null) {
            if (myLOD3Selector.isAllowed(getLOD3DataSet(), aW)) {

//warning! This simplification may destroy intersections because
// not all ways are known yet.
//                List<WayNode> fewNodes = getWayHelper().simplifyWay(simpleWay, simplificationThresholdLOD3, nodeDistanceThresholdLOD3, false);
//                if (simpleWay.getWayNodes().size() < fewNodes.size()) {
//                    simpleWay = new Way(aW.getId(), aW.getVersion(), aW.getTimestamp(), aW.getUser(), aW.getTags(), fewNodes);
//                    // set the nodes for the simplified way
//                    nodes = getWayHelper().getNodes(simpleWay);
//                }
//
//                combineSplitWays(getLOD3DataSet(), simpleWay, nodes, minSizeLOD3, simplificationThresholdLOD3, nodeDistanceThresholdLOD3, myLOD3Selector);
                // combine all parts of the relation into a single way
                // simplify that one and add it with a special role to the relation
                combineSpitWays(getLOD3DataSet(), compoundWayRelationWithSimplifiedRoles, compoundWaysBaseLOD, simpleWay, minSizeLOD3,
                        compoundWayLOD1, simplificationThresholdLOD3, nodeDistanceThresholdLOD3, myLOD3Selector);

            }
        } else if (landuse != null || natural != null) {
            if (myLOD3Selector.isAllowed(getLOD1DataSet(), aW)) {
                //simplify area
                List<WayNode> simpleArea = getBaseDataSet().getWayHelper().simplifyWay(aW, simplificationThresholdLOD3, nodeDistanceThresholdLOD3, false, false);
                WayBuilder simpleAreaWay = new WayBuilder(aW.getId(), aW.getVersion(), aW.getTimestamp(), aW.getUser(), 0);
                simpleAreaWay.getTags().addAll(aW.getTags());
                for (WayNode wayNode : simpleArea) {
                    simpleAreaWay.addWayNode(wayNode);
                    Node node = getBaseDataSet().getNodeByID(wayNode.getNodeId());
                    if (node != null) {
                        getLOD3DataSet().addNode(extendedNodeToNode(node));
                    }
                }
                getLOD3DataSet().addWay(simpleAreaWay.buildEntity());
            }
        }

    }



//    /**
//     * Combine the already simplified way with other ways
//     * that are part of it's type=compound/type=street -relation.
//     * @param aDataSet the LOD1,2 or 3 -DataSet
//     * @param aSimpleWay the simplified single way
//     * @param aNodes the nodes of that way
//     * @param aMinWaySize ignore compound ways shorter then this
//     * @param aSimplificationThreshold parameter for {@link WayHelper#simplifyWay(Way, double, double, boolean)}
//     * @param aNodeDistanceThreshold parameter for {@link WayHelper#simplifyWay(Way, double, double, boolean)}
//     * @param aSelector ignore ways that do not meet this selector's requirements
//     * @return true if the compound way is longer then this in lat or lon -direction
//     */
//    private boolean combineSplitWays(final IDataSet aDataSet,
//            final Way aSimpleWay,
//            final List<Node> aNodes,
//            final double aMinWaySize,
//            final double aSimplificationThreshold,
//            final double aNodeDistanceThreshold,
//            final Selector aSelector) {
//        // get or create the relation of type=compound for the way.
//        Relation relation = getOrCreateCompoundWay(aDataSet, aSimpleWay);
//
//        // then combine all parts of the relation into a single way
//        // simplify that one and add it with a special role to the relation
//        return combineSpitWays(aDataSet, aSimpleWay, aMinWaySize,
//                relation, aSimplificationThreshold, aNodeDistanceThreshold, aSelector);
//    }

    /**
     * @param aRelation the relation who's members to combine, may be null
     * @param aDataSet the LOD-level we are operating on
     * @param aCompoundWaysBaseLOD The ways in the baseDatSet that are to be combined (not yet simplified)
     * @param aCompoundWayRelationWithSimplifiedRoles the relation grouping all the combinedWays
     * @param aSimpleWay the way that has just changed/is being added
     * @param aMinWaySize the combined way must be at least this long
     * @param aNodeDistanceThreshold  Minimum distance between 2 nodes in polyline-simplifiction
     * @param aSimplificationThreshold Minimum xte(course error) in polyline-simplification
     * @param aSelector ignore ways not meeting this selector
     * @return true if at least one way was added to the dataSet
     */
    private boolean combineSpitWays(final IDataSet aDataSet,
            final RelationBuilder aCompoundWayRelationWithSimplifiedRoles,
            final WayBuilder[] aCompoundWaysBaseLOD, final Way aSimpleWay,
            final double aMinWaySize,
            final Relation aRelation,
            final double aSimplificationThreshold,
            final double aNodeDistanceThreshold,
            final Selector aSelector) {


        int added = 0;
        for (WayBuilder wayBuilder : aCompoundWaysBaseLOD) {
         // determine if the combined way is long enough
            // to be a part of the given LayerOfDetail
            double minLat = Double.MAX_VALUE;
            double minLon = Double.MAX_VALUE;
            double maxLat = Double.MIN_VALUE;
            double maxLon = Double.MIN_VALUE;
            List<Node> nodes = new LinkedList<Node>();
            //simplify combined way
            List<WayNode> simplifyWayNodes = getBaseDataSet().getWayHelper().simplifyWay(wayBuilder.getWayNodes(), aSimplificationThreshold, aNodeDistanceThreshold, false, false);

            for (WayNode wn : simplifyWayNodes) {
                Node n = getBaseDataSet().getNodeByID(wn.getNodeId());
                if (n == null) {
                    continue;
                }
                nodes.add(n);
                minLat = Math.min(minLat, n.getLatitude());
                maxLat = Math.max(maxLat, n.getLatitude());
                minLon = Math.min(minLon, n.getLongitude());
                maxLon = Math.max(maxLon, n.getLongitude());
            }
            if (Math.max(maxLat - minLat, maxLon - minLon) < aMinWaySize) {
                continue;
            }
            if (nodes.size() < 2) {
                continue;
            }
            // add the way to this layer
            for (Node n : nodes) {
                n = extendedNodeToNode(n);
                aDataSet.addNode(n);
            }
            WayBuilder simpleWay = new WayBuilder(wayBuilder.buildEntity());
            simpleWay.clearWayNodes();
            simpleWay.getWayNodes().addAll(simplifyWayNodes);
            aDataSet.addWay(extendedWayToWay(simpleWay.buildEntity()));
            aCompoundWayRelationWithSimplifiedRoles.addMember(new RelationMember(simpleWay.getId(), EntityType.Way, SIMPLIFIEDWAYRELATIONROLE));
            added++;
        }
        // size == 2 means that only a 1 way and 1 simplifiedWay are members
        if (aCompoundWayRelationWithSimplifiedRoles != null && aCompoundWayRelationWithSimplifiedRoles.getMembers().size() > 2) {
            aDataSet.addRelation(aCompoundWayRelationWithSimplifiedRoles.buildEntity());
            // remove all ways of the relation except
            // the simplified one from this LOD
            // as all it`s information is already a
            // part of the simplified way
            List<RelationMember> memberList = aCompoundWayRelationWithSimplifiedRoles.getMembers();
            for (RelationMember relationMember : memberList) {
                if (relationMember.getMemberType().equals(EntityType.Way)
                       && relationMember.getMemberRole() != null
                       && !SIMPLIFIEDWAYRELATIONROLE.equalsIgnoreCase(relationMember.getMemberRole())
                       && aDataSet != getBaseDataSet()) {
                    Way removeMe = aDataSet.getWaysByID(relationMember.getMemberId());
                    if (removeMe != null) {
                        aDataSet.removeWay(removeMe);
                    }
                }
            }
        }

        return added > 0;
    }


    /**
     * We may read an extended way from
     * the base-LOD but should never write
     * that to another LOD because the
     * relations it contains may
     * not exist in that other LOD.
     * @param aWay the way to simplify
     * @return a simple way.
     */
    private Way extendedWayToWay(final Way aWay) {
        if (aWay instanceof ExtendedWay) {
            Way retval = new Way(aWay.getId(), aWay.getVersion(), aWay.getTimestamp(), aWay.getUser(), aWay.getChangesetId());
            retval.getTags().addAll(aWay.getTags());
            retval.getWayNodes().addAll(aWay.getWayNodes());
            return retval;
        }
        return aWay;
    }

    /**
     * We may read an extended node from
     * the base-LOD but should never write
     * that to another LOD because the
     * ways and relations it contains may
     * not exist in that other LOD.
     * @param aNx the node to simplify
     * @return a simple node.
     */
    private Node extendedNodeToNode(final Node aNx) {
        if (aNx == null) {
            throw new IllegalArgumentException("null node given");
        }
        if (aNx instanceof ExtendedNode) {
            Node retval = new Node(aNx.getId(), aNx.getVersion(), aNx.getTimestamp(), aNx.getUser(), aNx.getChangesetId(), aNx.getLatitude(), aNx.getLongitude());
            retval.getTags().addAll(aNx.getTags());
            return retval;
        }
        return aNx;
    }

//    private Relation addRelationMember(final Relation aRel, final RelationMember aNewMember) {
//        ArrayList<RelationMember> newMembers = new ArrayList<RelationMember>(aRel.getMembers().size() + 1);
//        newMembers.addAll(aRel.getMembers());
//        newMembers.add(aNewMember);
//        return new Relation(aRel.getId(), aRel.getVersion(), aRel.getTimestamp(), aRel.getUser(),
//                aRel.getTags(), newMembers);
//    }
    /**
     * Combine the ways that are a part of this type=compound/type=street -relation
     * into as few ways as possible (The list of the  relation`s members of role
     * {@link #SIMPLIFIEDWAYRELATIONROLE} is changed in the process and the relation not saved).
     * @param aRelation the relation to examine, may be null
     * @param aSimpleWay this is a single way that has changed
     * @return the ways (NOT SIMPLIFIED)
     */
    private WayBuilder[] combineCompoundWay(final RelationBuilder aRelation,
            final Way aSimpleWay) {
        if (aRelation == null) {
            return new WayBuilder[] {new WayBuilder(aSimpleWay)};
        }
        //TODO: remove old generated ways when we get a new version of the relation
        List<RelationMember> members = new ArrayList<RelationMember>(aRelation.getMembers());
        // we assume ordered relations (api 0.6)
        List<WayBuilder> retval = new LinkedList<WayBuilder>();
//        List<WayNode> currentWayNodes = new LinkedList<WayNode>();
//        Map<String, Tag> tagsToPreserve = new HashMap<String, Tag>();
//        long currentWayId = (long) (Math.random() * Integer.MIN_VALUE);

        for (RelationMember member : members) {
            if (member.getMemberType() != EntityType.Way) {
                continue;
            }
            if (member.getMemberRole() != null && SIMPLIFIEDWAYRELATIONROLE.equals(member.getMemberRole())) {
                // remove existing "simplifiedWay"-members as we are generating new ones
//                Relation old = aRelation[0];
//                ArrayList<RelationMember> newMembers = new ArrayList<RelationMember>(old.getMembers());
//                newMembers.remove(member);
//                aRelation[0] = new Relation(old.getId(), old.getVersion(), old.getTimestamp(), old.getUser(), old.getTags(), newMembers);
                aRelation.getMembers().remove(member);
                continue;
            }

            Way part = null;
            if (aSimpleWay != null && member.getMemberId() == aSimpleWay.getId()) {
                part = aSimpleWay;
            } else {
                part = getBaseDataSet().getWaysByID(member.getMemberId());
            }
            if (part == null || part.getWayNodes().size() < 2 || !myLOD1Selector.isAllowed(getBaseDataSet(), part)) {
                continue;
            }

            // join connected, consecutive ways
            // add "part" at the end of  currentWayNodes
            boolean existingWayFound = false;
            for (WayBuilder existing : retval) {
                existingWayFound = mergeWays(part, existing);
                if (existingWayFound) {
                    // see if we can merge 2 existing ways now
                    // ("part" may have been the missing link)
                    for (WayBuilder otherExisting : retval) {
                        if (existing == otherExisting) {
                            continue;
                        }
                        if (mergeWays(otherExisting.buildEntity(), existing)) {
                            retval.remove(otherExisting);
                            break;
                        }
                    }
                    break;
                }
            }
            if (existingWayFound) {
                continue;
            }
            //I cannot connect this part to an existing part
            long currentWayId = (long) (Math.random() * Integer.MIN_VALUE);
//            LOG.finer("DEBUG: new             as " + currentWayId + " way " + part.getId());

            if (part.getWayNodes().size() > 1) {
                WayBuilder currentWay1 = new WayBuilder(currentWayId, 0, new Date(), null, 0);
                Map<String, Tag> tagsToPreserve = new HashMap<String, Tag>();
                collectTagsToKeep(part, tagsToPreserve);
                currentWay1.getTags().addAll(tagsToPreserve.values());
                currentWay1.getWayNodes().addAll(part.getWayNodes());
                retval.add(currentWay1);
                aRelation.addMember(new RelationMember(currentWayId, EntityType.Way, SIMPLIFIEDWAYRELATIONROLE));
            }
        }
        //currentWayNodes = getWayHelper().simplifyWay(currentWayNodes, aSimplificationThreshold, aNodeDistanceThreshold, false);
        return retval.toArray(new WayBuilder[retval.size()]);
    }

    /**
     * @param part the new way to attach
     * @param existing the existing way to try attaching to
     * @return true if they where merged
     */
    protected boolean mergeWays(final Way part, final WayBuilder existing) {
        if (existing.getWayNodes().size() == 0) {
            return false;
        }
        if (part.getWayNodes().size() == 0) {
            return true;
        }
        //    final String TAGOLDFIRST ="autogen:TS:LODDataSet:fist";
        //    final String TAGOLDLAST ="autogen:TS:LODDataSet:last";
        WayNode firstNode = existing.getWayNodes().get(0);
        WayNode lastNode = existing.getWayNodes().get(existing.getWayNodes().size() - 1);
        WayNode first =  part.getWayNodes().get(0);
        WayNode last = part.getWayNodes().get(part.getWayNodes().size() - 1);
        List<WayNode> partWayNodes     = part.getWayNodes();
        List<WayNode> existingWayNodes = existing.getWayNodes();
        // try to merge these as 1 motorway made up of 2 parallel oneway-ways for the 2 directions

        WayHelper wayHelper = getBaseDataSet().getWayHelper();
        if (mergeWaysNew(part, existing)) {
            return true;
        }

        // do they match in reversed direction?
        if ((lastNode == null || lastNode.getNodeId() == last.getNodeId())
                || (firstNode == null || firstNode.getNodeId() == first.getNodeId())) {
            WayNode temp = last;
            last = first;
            first = temp;
            Collections.reverse(partWayNodes);
        }

        // try to merge these as 1 street split at a point in the middle
        if (lastNode == null || lastNode.getNodeId() == first.getNodeId()) {

            //        LOG.finer("DEBUG: left    merging of " + existing.getId() + " and " + part.getId() + " on node " + first.getNodeId());
            Iterator<WayNode> addNodes = partWayNodes.iterator();
            // don`t duplicate the node consecutive ways have in common
            if (lastNode != null) {
                addNodes.next();
            }
            if (firstNode == null) {
                firstNode = first;
            }
            while (addNodes.hasNext()) {
                existingWayNodes.add(addNodes.next());
            }
            lastNode = last;
            return true;
            // prepend "part" to the start of  currentWayNodes
        } else if (firstNode.getNodeId() == last.getNodeId()) {

            //        LOG.finer("DEBUG: right   merging of " + existing.getId() + " and " + part.getId() + " on node " + first.getNodeId());
            Iterator<WayNode> addNodes = partWayNodes.iterator();
            int insertPosition = 0;
            while (addNodes.hasNext()) {
                WayNode addMe = addNodes.next();
                // don`t duplicate the node consecutive ways have in common
                if (addMe.getNodeId() == firstNode.getNodeId()) {
                    continue;
                }
                existingWayNodes.add(insertPosition, addMe);
                insertPosition++;
            }
            firstNode = first;
            return true;
        }
        return false;
    }

    /**
     * @param part the new way to attach
     * @param existing the existing way to try attaching to
     * @return true if they where merged
     */
    private boolean mergeWaysNew(final Way part, final WayBuilder existing) {
        WayHelper wayHelper = getBaseDataSet().getWayHelper();
        List<Node> existingNodes = wayHelper.getNodes(existing.getWayNodes());
        List<Node> partNodes     = wayHelper.getNodes(part);

        List<Node> parallel      = wayHelper.isParallel(existingNodes, partNodes);
        if (parallel != null) {
            //        LOG.finer("DEBUG: parallel merging of " + existing.getId() + " and " + part.getId());
            // mantis 0000052: merge parallel or partly parallel ways making up 2 lanes of the same road
            existing.clearWayNodes();
            long lastNodeID = Long.MIN_VALUE;

            for (Node node : parallel) {
                long nodeID = node.getId();
                if (lastNodeID != nodeID) { // else we would duplicate shared nodes
                    existing.getWayNodes().add(new WayNode(nodeID));
                }
                lastNodeID = nodeID;
            }

            // remove oneway-tag
            Collection<Tag> tags = existing.getTags();
            for (Tag tag : tags) {
                if (tag.getKey().equalsIgnoreCase("oneway")) {
                    tags.remove(tag);
                    break;
                }
            }
            return true;
        }
        return false;
    }

    /**
     * Collect the tags of the member-ways we should preserve on the simplified way.
     * @param aPart a way that is part of the collected way
     * @param aTagsToPreserve the tags collected so far
     */
    private void collectTagsToKeep(final Way aPart, final Map<String, Tag> aTagsToPreserve) {
        Collection<Tag> tagList = aPart.getTags();
        for (Tag tag : tagList) {
            if (tag == null) {
                continue;
            }
            if (tag.getKey() == null) {
                continue;
            }
            if (tag.getValue() == null) {
                continue;
            }
            if (tag.getKey().equalsIgnoreCase(Tags.TAG_HIGHWAY)
                    || tag.getKey().equalsIgnoreCase(Tags.TAG_NAME)
                    || tag.getKey().equalsIgnoreCase(Tags.TAG_REF)) {
                aTagsToPreserve.put(tag.getKey(), tag);
            }
        }
    }

    /**
     * find the first relation of type=compound/type=street for the way.
     * if None exists, create one.
     * @see http://wiki.openstreetmap.org/wiki/Relations/Proposed/Collected_Ways
     * @param aDataSet the LOD1,2 or 3 -dataSet
     * @param aSimpleWay the way that is or is to become a part of the relation
     * @return the relation or null
     */
    private Relation getOrCreateCompoundWayLOD123(final Way aSimpleWay) {
        // check if the way is already a part of a type=compound -relation
        Relation compound = getCompountRelationForWay(aSimpleWay);

        if (compound == null) {
            // create a type=compound/type=street -relation containing this way and all connected ways
            // that are a part of the same street (e.g. long motorway broken up)
            //Collection<Tag> tags = new LinkedList<Tag>();
            //tags.add(new Tag(AUTOGENERATEDTAG, "true"));
            RelationBuilder compoundBuilder = new RelationBuilder((long) (Math.random() * Integer.MIN_VALUE), 0, new Date(), null, 0);
            compoundBuilder.addTag(new Tag(AUTOGENERATEDTAG, "true"));
            compoundBuilder.addTag(new Tag("type", "street"));
            compoundBuilder = collectCompoundWay(compoundBuilder, aSimpleWay);
            /*if (compoundBuilder.getMembers().size() == 1) {
                compound = null;
            } else*/ {
                if (compoundBuilder == null) {
                    return null;
                }
                compound = compoundBuilder.buildEntity();
                getBaseDataSet().addRelation(compound); // we require the relation to be present in the baseDataSet, to identify existing ones
//TODO: remove generated ways in LOD1-3 in existing relation with this ID before adding the new one
                Relation existing = getLOD1DataSet().getRelationByID(compound.getId());
                if (existing != null) {
                    for (RelationMember member : existing.getMembers()) {
                        if (member.getMemberRole() != null && member.getMemberRole().equalsIgnoreCase(SIMPLIFIEDWAYRELATIONROLE)) {
                            Way removeMe = getLOD1DataSet().getWaysByID(member.getMemberId());
                            if (removeMe != null) {
                                getLOD1DataSet().removeWay(removeMe);
                            }
                        }
                    }
                }
                getLOD1DataSet().addRelation(compound);
                existing = getLOD2DataSet().getRelationByID(compound.getId());
                if (existing != null) {
                    for (RelationMember member : existing.getMembers()) {
                        if (member.getMemberRole() != null && member.getMemberRole().equalsIgnoreCase(SIMPLIFIEDWAYRELATIONROLE)) {
                            Way removeMe = getLOD2DataSet().getWaysByID(member.getMemberId());
                            if (removeMe != null) {
                                getLOD2DataSet().removeWay(removeMe);
                            }
                        }
                    }
                }
                getLOD2DataSet().addRelation(compound);
                existing = getLOD3DataSet().getRelationByID(compound.getId());
                if (existing != null) {
                    for (RelationMember member : existing.getMembers()) {
                        if (member.getMemberRole() != null && member.getMemberRole().equalsIgnoreCase(SIMPLIFIEDWAYRELATIONROLE)) {
                            Way removeMe = getLOD3DataSet().getWaysByID(member.getMemberId());
                            if (removeMe != null) {
                                getLOD3DataSet().removeWay(removeMe);
                            }
                        }
                    }
                }
                getLOD3DataSet().addRelation(compound);
            }
        }
        return compound;
    }

    /**
     * Collect all connected ways that have the same ref or name as the given way.
     * @param aCompound the relation so far
     * @param aWay the current way
     * @return the relation. (May have been changed from the parameter or be null upon encountering an existing relation)
     */
    private RelationBuilder collectCompoundWay(RelationBuilder aCompound, final Way aWay) {
        if (!containsWay(aCompound, aWay.getId())) {
            aCompound.addMember(new RelationMember(aWay.getId(), EntityType.Way, ""));
            //aCompound[0] = addRelationMember(aCompound[0], new RelationMember(aWay.getId(), EntityType.Way, ""));
        }

        String name = WayHelper.getTag(aWay, Tags.TAG_NAME);
        String ref = WayHelper.getTag(aWay, Tags.TAG_REF);
        String highway = WayHelper.getTag(aWay, Tags.TAG_HIGHWAY);
        List<WayNode> wayNodes = aWay.getWayNodes();
        for (WayNode wayNode : wayNodes) {

            // we look at the base dataset because the ways to collect may be too small
            // for the current LOD-level without being combined into a long way
            Iterator<Way> ways = getBaseDataSet().getWaysForNode(wayNode.getNodeId());
            while (ways != null && ways.hasNext()) {
                Way otherWay = ways.next();
                if (otherWay.getId() == aWay.getId()) {
                    continue; // this is us
                }
                if (containsWay(aCompound, otherWay.getId())) {
                    continue; // we have seen this way before
                }
                if (!myLOD1Selector.isAllowed(getBaseDataSet(), otherWay)) {
                    continue; // the components have to at least pass the feature-selection of LOD1
                }


                // check if the other way is a part of the same (split up) way as the current one
                // by comparing either the "name" or the "ref" -attribute
                String otherName = WayHelper.getTag(otherWay, Tags.TAG_NAME);
                String otherRef = WayHelper.getTag(otherWay, Tags.TAG_REF);
                boolean sameRef = otherRef != null && ref != null && ref.trim().length() > 0 && otherRef.equalsIgnoreCase(ref);
                boolean sameName = otherName != null && name != null && name.trim().length() > 0 && otherName.equalsIgnoreCase(name);
                if (!sameRef && !sameName) {
                    continue; // this is a completely different way
                }
                // do not combine a XXX with an XXX_link
                // this will make the combined roads much longer, cleaner and better to simplify
                if (highway != null) {
                    String otherHighway = WayHelper.getTag(otherWay, Tags.TAG_HIGHWAY);
                    if (otherHighway != null) {
                        boolean isLink = highway.toLowerCase().endsWith("_link");
                        boolean otherIsLink = otherHighway.toLowerCase().endsWith("_link");
                        if (isLink && !otherIsLink) {
                            continue;
                        }
                        if (!isLink && otherIsLink) {
                            continue;
                        }
                    }
                }

                // check if otherWay is a part of another compoundWay-relation => join the relations
                Relation otherRelation = getCompoundRelation(otherWay, getBaseDataSet());
                if (otherRelation != null) {
                    if (!isAutoGenerated(otherRelation.getTags())) {
                        //if other relation is not autoGenerated => return null
                        //manually generated relation take priority
                        return null;
                    }
                    RelationBuilder otherRelationBuilder = new RelationBuilder(otherRelation);
                    // else, add all members of this relation to the other one and set compoundRelation=otherRelation
                    List<RelationMember> toAdd = aCompound.getMembers();
                    for (RelationMember relationMember : toAdd) {
                        if (relationMember.getMemberType() != EntityType.Way) {
                            continue;
                        }
                        if (relationMember.getMemberRole() != null && relationMember.getMemberRole().equalsIgnoreCase(SIMPLIFIEDWAYRELATIONROLE)) {
                            Way deleteMe = getBaseDataSet().getWaysByID(relationMember.getMemberId());
                            if (deleteMe != null) {
                                getBaseDataSet().removeWay(deleteMe);
                            }
                            deleteMe = getLOD1DataSet().getWaysByID(relationMember.getMemberId());
                            if (deleteMe != null) {
                                getLOD1DataSet().removeWay(deleteMe);
                            }
                            deleteMe = getLOD2DataSet().getWaysByID(relationMember.getMemberId());
                            if (deleteMe != null) {
                                getLOD2DataSet().removeWay(deleteMe);
                            }
                            deleteMe = getLOD3DataSet().getWaysByID(relationMember.getMemberId());
                            if (deleteMe != null) {
                                getLOD3DataSet().removeWay(deleteMe);
                            }
                            continue;
                        }
                        if (!containsWay(otherRelationBuilder, relationMember.getMemberId())) {
                            otherRelationBuilder.addMember(new RelationMember(relationMember.getMemberId(), EntityType.Way, ""));
                            //otherRelation[0] = addRelationMember(otherRelation[0], new RelationMember(relationMember.getMemberId(), EntityType.Way, ""));
                        }
                    }
                    aCompound = otherRelationBuilder;
                    // if the current way is now already in the relation, skip it
                    if (containsWay(aCompound, otherWay.getId())) {
                        continue;
                    }
                }

                aCompound.addMember(new RelationMember(otherWay.getId(), EntityType.Way, ""));
                aCompound = collectCompoundWay(aCompound, otherWay);
                if (aCompound == null) {
                    return null;
                }


            }
        }
        return aCompound;
    }

    /**
     * Check if the element that carries the given tags is automatically
     * generated by an LODDataSet.
     * @param tags the tags of an entity
     * @return true if we generated this entity outself
     */
    private boolean isAutoGenerated(final Collection<Tag> tags) {
        for (Tag tag : tags) {
            if (tag.getKey() != null && tag.getKey().equalsIgnoreCase(AUTOGENERATEDTAG)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Check all relations of the given way and return the first
     * relation of type=compound or type=street or null.
     * @param aWay the way to check
     * @param aDataSet the LOD-level to look at
     * @return the relation or null if not found
     */
    private Relation getCompoundRelation(final Way aWay, final IDataSet aDataSet) {
        if (aWay instanceof ExtendedWay) {
            ExtendedWay extWay = (ExtendedWay) aWay;
            Set<Long> referencedRelationIDs = extWay.getReferencedRelationIDs();
            for (Long relID : referencedRelationIDs) {
                Relation relation = aDataSet.getRelationByID(relID);
                if (relation != null && isCompoundWay(relation)) {
                    return relation;
                }
            }
        }
        return null;
    }

//    /**
//     * @param aRelation the relation to check
//     * @param aWayID the way to look for
//     * @return true if the relation contains the given way
//     */
//    private boolean containsWay(final Relation aRelation, final long aWayID) {
//        //  this may belong into a RelationHelper
//        List<RelationMember> members = aRelation.getMembers();
//        for (RelationMember relationMember : members) {
//            if (relationMember.getMemberType() != EntityType.Way) {
//                continue;
//            }
//            if (relationMember.getMemberId() == aWayID) {
//                return true;
//            }
//        }
//        return false;
//    }
    /**
     * @param aRelation the relation to check
     * @param aWayID the way to look for
     * @return true if the relation contains the given way
     */
    private boolean containsWay(final RelationBuilder aRelation, final long aWayID) {
        // TODO this may belong into a RelationHelper
        List<RelationMember> members = aRelation.getMembers();
        for (RelationMember relationMember : members) {
            if (relationMember.getMemberType() != EntityType.Way) {
                continue;
            }
            if (relationMember.getMemberId() == aWayID) {
                return true;
            }
        }
        return false;
    }

    /**
     * If the given way is a part of a CompoundWay,
     * return the relation that combines all ways
     * that are a part of this CompoundWay.
     * @param way the way to examine
     * @return the relation or null
     */
    private Relation getCompountRelationForWay(final Way way) {
        if (way instanceof ExtendedWay) {
            ExtendedWay extWay = (ExtendedWay) way;
            Set<Long> relations = extWay.getReferencedRelationIDs();
            for (Long relID : relations) {
                Relation rel = getBaseDataSet().getRelationByID(relID);
                if (isCompoundWay(rel)) {
                    return rel;
                }
            }
        }
        return null;
    }

    /**
     * @param aRel the relation to test.
     * @return true if this is a relation grouping a street split up into multiple ways
     */
    private boolean isCompoundWay(final Relation aRel) {
        if (aRel == null) {
            return false;
        }
        // TODO if multiple exist and one is generated by us, remove the auto-generated one
        Collection<Tag> tags = aRel.getTags();
        for (Tag tag : tags) {
            if (tag.getKey() != null && tag.getKey().equals("type")) {
                if (tag.getValue() != null && tag.getValue().equalsIgnoreCase("compound")) {
                    return true;
                }
                if (tag.getValue() != null && tag.getValue().equalsIgnoreCase("street")) {
                    return true;
                }
            }
            if (tag.getKey() != null && tag.getKey().equals("collection")) {
                if (tag.getValue() != null && tag.getValue().equalsIgnoreCase("street")) {
                    return true;
                }
            }
        }
        return false;
    }

    /**
     * ${@inheritDoc}.
     */
    public boolean containsNode(final Node aW) {
        if (getBaseDataSet() instanceof OsmBinDataSet
            || getBaseDataSet() instanceof DBDataSet) {
            // these data-sets are indexed. It makes
            // no sense to ask the lower zoom -maps first
            return getBaseDataSet().containsNode(aW);
        }
     // look in simplified maps first
        return getLOD3DataSet().containsNode(aW)
          || getLOD2DataSet().containsNode(aW)
          || getLOD1DataSet().containsNode(aW)
          || getBaseDataSet().containsNode(aW);
    }

    /**
     * ${@inheritDoc}.
     */
    public boolean containsRelation(final Relation aR) {
        if (getBaseDataSet() instanceof OsmBinDataSet
                || getBaseDataSet() instanceof DBDataSet
                || getBaseDataSet() instanceof H2DataSet) {
            // these data-sets are indexed. It makes
            // no sense to ask the lower zoom -maps first
            return getBaseDataSet().containsRelation(aR);
        }
        // look in simplified maps first
        return getLOD3DataSet().containsRelation(aR)
        || getLOD2DataSet().containsRelation(aR)
        || getLOD1DataSet().containsRelation(aR)
        || getBaseDataSet().containsRelation(aR);
    }

    /**
     * ${@inheritDoc}.
     */
    public boolean containsWay(final Way aW) {
        if (getBaseDataSet() instanceof OsmBinDataSet
                || getBaseDataSet() instanceof DBDataSet
                || getBaseDataSet() instanceof H2DataSet) {
            // these data-sets are indexed. It makes
            // no sense to ask the lower zoom -maps first
            return getBaseDataSet().containsWay(aW);
        }
        // look in simplified maps first
        return getLOD3DataSet().containsWay(aW)
        || getLOD2DataSet().containsWay(aW)
        || getLOD1DataSet().containsWay(aW)
        || getBaseDataSet().containsWay(aW);
    }

    /**
     * ${@inheritDoc}.
     */
    public Node getNearestNode(final LatLon aLastGPSPos, final Selector aSelector) {
        return getBaseDataSet().getNearestNode(aLastGPSPos, aSelector);
    }

    /**
     * ${@inheritDoc}.
     */
    public Node getNodeByID(final long aNodeID) {
        if (getBaseDataSet() instanceof OsmBinDataSet
                || getBaseDataSet() instanceof DBDataSet
                || getBaseDataSet() instanceof H2DataSet) {
            // these data-sets are indexed. It makes
            // no sense to ask the lower zoom -maps first
            return getBaseDataSet().getNodeByID(aNodeID);
        }

        // look in simplified maps first
        Node n = null;
        n = getLOD3DataSet().getNodeByID(aNodeID);
        if (n != null)
            return n;
        n = getLOD2DataSet().getNodeByID(aNodeID);
        if (n != null)
            return n;
        n = getLOD1DataSet().getNodeByID(aNodeID);
        if (n != null)
            return n;
        return getBaseDataSet().getNodeByID(aNodeID);
    }

    /**
     * ${@inheritDoc}.
     */
    public Iterator<Node> getNodes(final Bounds aBoundingBox) {
        return getBaseDataSet().getNodes(aBoundingBox);
    }

    /**
     * ${@inheritDoc}.
     */
    public Iterator<Node> getNodesByName(final String aLookFor) {
        return getBaseDataSet().getNodesByName(aLookFor);
    }

    /**
     * ${@inheritDoc}.
     */
    public Iterator<Node> getNodesByTag(final String aKey, final String aValue) {
        return getBaseDataSet().getNodesByTag(aKey, aValue);
    }

    /**
     * ${@inheritDoc}.
     */
    public Relation getRelationByID(final long aRelationID) {
        if (getBaseDataSet() instanceof OsmBinDataSet
                || getBaseDataSet() instanceof DBDataSet
                || getBaseDataSet() instanceof H2DataSet) {
            // these data-sets are indexed. It makes
            // no sense to ask the lower zoom -maps first
            return getBaseDataSet().getRelationByID(aRelationID);
        }
        // look in simplified maps first
        Relation n = null;
        n = getLOD3DataSet().getRelationByID(aRelationID);
        if (n != null)
            return n;
        n = getLOD2DataSet().getRelationByID(aRelationID);
        if (n != null)
            return n;
        n = getLOD1DataSet().getRelationByID(aRelationID);
        if (n != null)
            return n;
        return getBaseDataSet().getRelationByID(aRelationID);
    }

    /**
     * ${@inheritDoc}.
     */
    public Iterator<Relation> getRelations(final Bounds aBoundingBox) {
        return getBaseDataSet().getRelations(aBoundingBox);
    }

    /**
     * ${@inheritDoc}.
     */
    public WayHelper getWayHelper() {
        return getBaseDataSet().getWayHelper();
    }

    /**
     * ${@inheritDoc}.
     */
    public Iterator<Way> getWays(final Bounds aBoundingBox) {
        return getBaseDataSet().getWays(aBoundingBox);
    }

    /**
     * ${@inheritDoc}.
     */
    public Way getWaysByID(final long aWayID) {
        // do NOT look in simplified maps first
        // we want to give no simplified ways
        // unless clients explicitely ask for it.
        return getBaseDataSet().getWaysByID(aWayID);
    }

    /**
     * ${@inheritDoc}.
     */
    public Iterator<Way> getWaysByName(final String aLookFor, final Bounds aBoundingBox) {
//      TODO look in simplified maps first
        return getBaseDataSet().getWaysByName(aLookFor, aBoundingBox);
    }

    /**
     * ${@inheritDoc}.
     */
    public Iterator<Way> getWaysByTag(final String aKey, final String aValue) {
//       look in simplified maps first
        return getBaseDataSet().getWaysByTag(aKey, aValue);
    }

    /**
     * ${@inheritDoc}.
     */
    public Iterator<Way> getWaysForNode(final long aNodeID) {
        return getBaseDataSet().getWaysForNode(aNodeID);
    }

    /**
     * ${@inheritDoc}.
     */
    public void removeNode(final Node aW) {
        getBaseDataSet().removeNode(aW);
        getLOD1DataSet().removeNode(aW);
        getLOD2DataSet().removeNode(aW);
        getLOD3DataSet().removeNode(aW);
    }

    /**
     * ${@inheritDoc}.
     */
    public void removeRelation(final Relation aR) {
        getBaseDataSet().removeRelation(aR);
        getLOD1DataSet().removeRelation(aR);
        getLOD2DataSet().removeRelation(aR);
        getLOD3DataSet().removeRelation(aR);
    }

    /**
     * ${@inheritDoc}.
     */
    public void removeWay(final Way aW) {
        getBaseDataSet().removeWay(aW);
        getLOD1DataSet().removeWay(aW);
        getLOD2DataSet().removeWay(aW);
        getLOD3DataSet().removeWay(aW);
    }

    /**
     * @return Returns the lOD1DataSet.
     * @see #myLOD1DataSet
     */
    public IDataSet getLOD1DataSet() {
        if (this.myLOD1DataSet == null) {
            //  = new FileTileDataSet("LOD1", 2);
            String defaultDir = Settings.getInstance().get("map.dir",
                                Settings.getInstance().get("tiledMapCache.dir",
                                System.getProperty("user.home")
                    + File.separator + ".openstreetmap" + File.separator + "map" + File.separator))
                    + "LOD1" + File.separator;
            File dir = new File(defaultDir);
            dir.mkdirs();
            //this.myLOD1DataSet = new H2DataSet(dir);
//            this.myLOD1DataSet = new OsmBinDataSet(dir);
            this.myLOD1DataSet = Settings.getInstance().getPlugin(IDataSet.class, H2DataSet.class.getName(), "LOD1", new Object[]{dir});

        }
        return myLOD1DataSet;
    }

    /**
     * @param aDataSet The lOD1DataSet to set.
     * @see #myLOD1DataSet
     */
    public void setLOD1DataSet(final IDataSet aDataSet) {
        if (aDataSet == null) {
            throw new IllegalArgumentException("null 'aDataSet' given!");
        }

        Object old = myLOD1DataSet;
        if (old == aDataSet) {
            return; // nothing has changed
        }
        myLOD1DataSet = aDataSet;
        // <<insert code to react further to this change here
//        PropertyChangeSupport propertyChangeFirer = getPropertyChangeSupport();
//        if (propertyChangeFirer != null) {
//            propertyChangeFirer.firePropertyChange("aDataSet", old, aDataSet);
//        }
    }

    /**
     * @return Returns the baseDataSet.
     * @see #myBaseDataSet
     */
    public IDataSet getBaseDataSet() {
        if (this.myBaseDataSet == null) {
            // = new FileTileDataSet("LOD0", 1)
            String defaultDir = Settings.getInstance().get("map.dir",
                    Settings.getInstance().get("tiledMapCache.dir",
                    System.getProperty("user.home")
                    + File.separator + ".openstreetmap" + File.separator + "map" + File.separator))
                    + "LOD0";
            File dir = new File(defaultDir);
            dir.mkdirs();
            this.myBaseDataSet = Settings.getInstance().getPlugin(IDataSet.class, H2DataSet.class.getName(), "LOD0", new Object[]{dir});
            //this.myBaseDataSet = new H2DataSet(dir);
            //this.myBaseDataSet = new OsmBinDataSet(dir);
        }
        return myBaseDataSet;
    }

    /**
     * @param aBaseDataSet The baseDataSet to set.
     * @see #myBaseDataSet
     */
    public void setBaseDataSet(final IDataSet aBaseDataSet) {
        if (aBaseDataSet == null) {
            throw new IllegalArgumentException("null 'aBaseDataSet' given!");
        }

        Object old = myBaseDataSet;
        if (old == aBaseDataSet) {
            return; // nothing has changed
        }
        myBaseDataSet = aBaseDataSet;
        // <<insert code to react further to this change here
//        PropertyChangeSupport propertyChangeFirer = getPropertyChangeSupport();
//        if (propertyChangeFirer != null) {
//            propertyChangeFirer.firePropertyChange("aBaseDataSet", old,
//                    aBaseDataSet);
//        }
    }

    /**
     * @return Returns the lOD2DataSet.
     * @see #myLOD2DataSet
     */
    public IDataSet getLOD2DataSet() {
        if (this.myLOD2DataSet == null) {
            //  = new FileTileDataSet("LOD2", LOD2_COMBINE_TILE_LEVEL)
            String defaultDir = Settings.getInstance().get("map.dir",
                    Settings.getInstance().get("tiledMapCache.dir",
                            System.getProperty("user.home")
                            + File.separator + ".openstreetmap" + File.separator + "map" + File.separator))
                            + "LOD2";
            File dir = new File(defaultDir);
            dir.mkdirs();
            //this.myLOD2DataSet = new H2DataSet(dir);
//            this.myLOD2DataSet = new OsmBinDataSet(dir);
            this.myLOD2DataSet = Settings.getInstance().getPlugin(IDataSet.class, H2DataSet.class.getName(), "LOD2", new Object[]{dir});
        }
        return myLOD2DataSet;
    }

    /**
     * @param aDataSet The lOD2DataSet to set.
     * @see #myLOD2DataSet
     */
    public void setLOD2DataSet(final IDataSet aDataSet) {
        if (aDataSet == null) {
            throw new IllegalArgumentException("null 'aDataSet' given!");
        }

        Object old = myLOD2DataSet;
        if (old == aDataSet) {
            return; // nothing has changed
        }
        myLOD2DataSet = aDataSet;
        // <<insert code to react further to this change here
//        PropertyChangeSupport propertyChangeFirer = getPropertyChangeSupport();
//        if (propertyChangeFirer != null) {
//            propertyChangeFirer.firePropertyChange("aDataSet", old, aDataSet);
//        }
    }


    /**
     * @return Returns the lOD2DataSet.
     * @see #myLOD3DataSet
     */
    public IDataSet getLOD3DataSet() {
        if (this.myLOD3DataSet == null) {
            //  = new FileTileDataSet("LOD3", LOD3_COMBINE_TILE_LEVEL)
            String defaultDir = Settings.getInstance().get("map.dir",
                    Settings.getInstance().get("tiledMapCache.dir",
                    System.getProperty("user.home")
                    + File.separator + ".openstreetmap" + File.separator + "map" + File.separator))
                    + "LOD3";
            File dir = new File(defaultDir);
            dir.mkdirs();
            //this.myLOD3DataSet = new H2DataSet(dir);
            //this.myLOD3DataSet = new OsmBinDataSet(dir);
            this.myLOD3DataSet = Settings.getInstance().getPlugin(IDataSet.class, H2DataSet.class.getName(), "LOD1", new Object[]{dir});
        }
        return myLOD3DataSet;
    }

    /**
     * @param aDataSet The lOD3DataSet to set.
     * @see #myLOD3DataSet
     */
    public void setLOD3DataSet(final IDataSet aDataSet) {
        if (aDataSet == null) {
            throw new IllegalArgumentException("null 'aDataSet' given!");
        }

        Object old = myLOD3DataSet;
        if (old == aDataSet) {
            return; // nothing has changed
        }
        myLOD3DataSet = aDataSet;
        // <<insert code to react further to this change here
//        PropertyChangeSupport propertyChangeFirer = getPropertyChangeSupport();
//        if (propertyChangeFirer != null) {
//            propertyChangeFirer.firePropertyChange("aDataSet", old, aDataSet);
//        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void shutdown() {
        if (this.myBaseDataSet != null) {
            this.myBaseDataSet.shutdown();
            this.myBaseDataSet = null;
        }
        if (this.myLOD1DataSet != null) {
            this.myLOD1DataSet.shutdown();
            this.myLOD1DataSet = null;
        }
        if (this.myLOD2DataSet != null) {
            this.myLOD2DataSet.shutdown();
            this.myLOD2DataSet = null;
        }
        if (this.myLOD3DataSet != null) {
            this.myLOD3DataSet.shutdown();
            this.myLOD3DataSet = null;
        }
    }

    /**
     * (c) 2008 by <a href="http://Wolschon.biz>Wolschon Softwaredesign und Beratung</a>.<br/>
     * Project: libosm<br/>
     * LODDataSet.java<br/>
     * created: 07.01.2009<br/>
     *<br/><br/>
     * Selector to define what gets included in the first
     * Level-Of-Detail DataSet.
     * @author <a href="mailto:Marcus@Wolschon.biz">Marcus Wolschon</a>
     */
    private class LOD1Selector implements Selector {

        /**
         * @param aNode the Node to test.
         * @param aMap the map we operate on.
         * @return true if we are allowed to use that Node.
         */
        public boolean isAllowed(final IDataSet aMap, final Node aNode) {
            String place = NodeHelper.getTag(aNode, "place");
            return place != null;
        }

        /**
         * @param aWay the way to test.
         * @param aMap the map we operate on.
         * @return true if we are allowed to use that way.
         */
        public boolean isAllowed(final IDataSet aMap, final Way aWay) {
            String boundary = WayHelper.getTag(aWay, Tags.TAG_BOUNDARY);
            if (boundary != null) {
                if (boundary.equalsIgnoreCase("administrative")) {
                    return true;
                }
            }

            String waterway = WayHelper.getTag(aWay, Tags.TAG_WATERWAY);
            if (waterway != null) {
                if (waterway.equalsIgnoreCase("river")
                        || waterway.equalsIgnoreCase("canal")) {
                    return true;
                }
                if (waterway.equalsIgnoreCase("riverbank")) {
                    Bounds bounds = WayHelper.getBoundsForWay(aWay, getBaseDataSet());
                    // test minimum size of the riverbank area
                    if (bounds != null && bounds.getSize() >= minSizeLOD1) {
                        return true;
                    }
                }
            }

            String highway = WayHelper.getTag(aWay, Tags.TAG_HIGHWAY);
            if (highway != null) {
                if (highway.equalsIgnoreCase("motorway")
                        || highway.equalsIgnoreCase("motorway_link")
                        || highway.equalsIgnoreCase("trunk")
                        || highway.equalsIgnoreCase("trunk_link")
                        || highway.equalsIgnoreCase("primary")
                        || highway.equalsIgnoreCase("primary_link")
                        || highway.equalsIgnoreCase("secondary")
                        || highway.equalsIgnoreCase("secondary_link")) {
                    return true;
                }
            }
            String landuse = WayHelper.getTag(aWay, Tags.TAG_LANDUSE);
            String natural = WayHelper.getTag(aWay, Tags.TAG_NATURAL);
            if (landuse != null || natural != null) {
                Bounds bounds = WayHelper.getBoundsForWay(aWay, getBaseDataSet());
                // test minimum size of the area
                if (bounds != null && bounds.getSize() >= minSizeLOD1) {
                    return true;
                }
            }

            return false;
        }

        /**
         * @param aRelation the relation to test.
         * @param aMap the map we operate on.
         * @return true if we are allowed to use that relaiton.
         */
        public boolean isAllowed(final IDataSet aMap, final Relation aRelation) {
            return false;
        }
    }

    /**
     * (c) 2008 by <a href="http://Wolschon.biz>Wolschon Softwaredesign und Beratung</a>.<br/>
     * Project: libosm<br/>
     * LODDataSet.java<br/>
     * created: 07.01.2009<br/>
     *<br/><br/>
     * Selector to define what gets included in the second
     * Level-Of-Detail DataSet.
     * @author <a href="mailto:Marcus@Wolschon.biz">Marcus Wolschon</a>
     */
    private class LOD2Selector implements Selector {

        /**
         * @param aNode the Node to test.
         * @param aMap the map we operate on.
         * @return true if we are allowed to use that Node.
         */
        public boolean isAllowed(final IDataSet aMap, final Node aNode) {
            String place = NodeHelper.getTag(aNode, "place");
            return place != null && place.equalsIgnoreCase("city");
        }

        /**
         * @param aWay the way to test.
         * @param aMap the map we operate on.
         * @return true if we are allowed to use that way.
         */
        public boolean isAllowed(final IDataSet aMap, final Way aWay) {
            String boundary = WayHelper.getTag(aWay, Tags.TAG_BOUNDARY);
            if (boundary != null) {
                if (boundary.equalsIgnoreCase("administrative")) {
                    return true;
                }
            }

            String waterway = WayHelper.getTag(aWay, Tags.TAG_WATERWAY);
            if (waterway != null) {
                if (waterway.equalsIgnoreCase("river")) {
                    return true;
                }
            }

            String highway = WayHelper.getTag(aWay, Tags.TAG_HIGHWAY);
            if (highway != null) {
                if (highway.equalsIgnoreCase("motorway")
                        || highway.equalsIgnoreCase("motorway_link")
                        || highway.equalsIgnoreCase("trunk")) {
                    return true;
                }
            }
            String landuse = WayHelper.getTag(aWay, Tags.TAG_LANDUSE);
            String natural = WayHelper.getTag(aWay, Tags.TAG_NATURAL);
            if (landuse != null || natural != null) {
                Bounds bounds = WayHelper.getBoundsForWay(aWay, getBaseDataSet());
                // test minimum size of the area
                if (bounds != null && bounds.getSize() >= minSizeLOD2) {
                    return true;
                }
            }
         return false;
        }

        /**
         * @param aRelation the relation to test.
         * @param aMap the map we operate on.
         * @return true if we are allowed to use that relaiton.
         */
        public boolean isAllowed(final IDataSet aMap, final Relation aRelation) {
            return false;
        }
    }

    /**
     * (c) 2008 by <a href="http://Wolschon.biz>Wolschon Softwaredesign und Beratung</a>.<br/>
     * Project: libosm<br/>
     * LODDataSet.java<br/>
     * created: 07.01.2009<br/>
     *<br/><br/>
     * Selector to define what gets included in the third
     * Level-Of-Detail DataSet.
     * @author <a href="mailto:Marcus@Wolschon.biz">Marcus Wolschon</a>
     */
    private class LOD3Selector implements Selector {

        /**
         * @param aNode the Node to test.
         * @param aMap the map we operate on.
         * @return true if we are allowed to use that Node.
         */
        public boolean isAllowed(final IDataSet aMap, final Node aNode) {
        	// LOG.info("isAllowed: "+aMap+", "+aNode);
        	
            String place = NodeHelper.getTag(aNode, "place");
            return place != null && place.equalsIgnoreCase("city");
        }

        /**
         * @param aWay the way to test.
         * @param aMap the map we operate on.
         * @return true if we are allowed to use that way.
         */
        public boolean isAllowed(final IDataSet aMap, final Way aWay) {
            String boundary = WayHelper.getTag(aWay, Tags.TAG_BOUNDARY);
            if (boundary != null) {
                if (boundary.equalsIgnoreCase("administrative")) {
                    return true;
                }
            }

            String highway = WayHelper.getTag(aWay, Tags.TAG_HIGHWAY);
            if (highway != null) {
                if (highway.equalsIgnoreCase("motorway")) {
                    return true;
                }
            }
            String landuse = WayHelper.getTag(aWay, Tags.TAG_LANDUSE);
            String natural = WayHelper.getTag(aWay, Tags.TAG_NATURAL);
            if (landuse != null || natural != null) {
                Bounds bounds = WayHelper.getBoundsForWay(aWay, getBaseDataSet());
                // test minimum size of the area
                if (bounds != null && bounds.getSize() >= minSizeLOD3) {
                    return true;
                }
            }
         return false;
        }

        /**
         * @param aRelation the relation to test.
         * @param aMap the map we operate on.
         * @return true if we are allowed to use that relaiton.
         */
        public boolean isAllowed(final IDataSet aMap, final Relation aRelation) {
            return false;
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ConfigurationSection getSettings() {
        ConfigurationSection retval = new ConfigurationSection("LODDataSet");

        String name = IDataSet.class.getName();
        name  = name.substring(name.lastIndexOf('.') + 1);

        ConfigurationSetting lod0 = new ConfigurationSetting(IDataSet.class, "base-map");
        lod0.setKey("plugin.useImpl." + name + ".LOD0");
        lod0.setRequiredRestart(true);
        retval.addSetting(lod0);

        ConfigurationSetting lod1 = new ConfigurationSetting(IDataSet.class, "LOD1-map");
        lod1.setKey("plugin.useImpl." + name + ".LOD1");
        lod1.setRequiredRestart(true);
        retval.addSetting(lod1);

        ConfigurationSetting lod2 = new ConfigurationSetting(IDataSet.class, "LOD2-map");
        lod2.setKey("plugin.useImpl." + name + ".LOD2");
        lod2.setRequiredRestart(true);
        retval.addSetting(lod2);

        ConfigurationSetting lod3 = new ConfigurationSetting(IDataSet.class, "LOD3-map");
        lod3.setKey("plugin.useImpl." + name + ".LOD3");
        lod3.setRequiredRestart(true);
        retval.addSetting(lod3);

        return retval;
    }

    /**
     * {@inheritDoc}.
     */
    @Override
    public void hintImportEnded() {
        IDataSet ds = getBaseDataSet();
        if (ds instanceof IHintableDataSet) {
            ((IHintableDataSet) ds).hintImportEnded();
        }
        ds = getLOD1DataSet();
        if (ds instanceof IHintableDataSet) {
            ((IHintableDataSet) ds).hintImportEnded();
        }
        ds = getLOD2DataSet();
        if (ds instanceof IHintableDataSet) {
            ((IHintableDataSet) ds).hintImportEnded();
        }
        ds = getLOD3DataSet();
        if (ds instanceof IHintableDataSet) {
            ((IHintableDataSet) ds).hintImportEnded();
        }
    }

    /**
     * {@inheritDoc}.
     */
    @Override
    public void hintImportStarting() {
        IDataSet ds = getBaseDataSet();
        if (ds instanceof IHintableDataSet) {
            ((IHintableDataSet) ds).hintImportStarting();
        }
        ds = getLOD1DataSet();
        if (ds instanceof IHintableDataSet) {
            ((IHintableDataSet) ds).hintImportStarting();
        }
        ds = getLOD2DataSet();
        if (ds instanceof IHintableDataSet) {
            ((IHintableDataSet) ds).hintImportStarting();
        }
        ds = getLOD3DataSet();
        if (ds instanceof IHintableDataSet) {
            ((IHintableDataSet) ds).hintImportStarting();
        }

    }

}


